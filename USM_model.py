# -*- coding: utf-8 -*-
"""SAC_USM_summary015082021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dkO9jeq8YQvj1qT2-Jm-qK8GoS3Ih7ow
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
from scipy import optimize as opt
import time 

class USM_model_sim:
  def __init__(self, m = 159e-3, d = 500, c = 10e9, cd = 10e-9, rd =5000, A = 0.25,
               h =  30e-3, r = 30e-3, k_r = 2e7, mu = 0.2,v_amp = 150, F_n = 170,
               T = 0, phase =1, tempMin = 20,  r_b = 30e-3, r_a = 10e-3,l = 20e-3,
               ru = 8400, sigma = 5.67e-8, h_c = 100, e = 0.8, s = 0.2e3, dt = 0,
              freq = 40, temp = 20, targetSpeed = 100 ):
    
    self.m0 = m*A**2        # modal mass
    self.d0 = d*A**2       # modal damping
    self.c0 = c*A**2       # modal stiffness
    self.C = c
    self.D = d
    self.M = m
    self.cd = cd      # damped capacitance
    self.rd = rd      # damped resistance
    self.A = A        # Coupling factor
    self.r = r        # radius of stator
    self.h = h        # height of contact surface
    self.k_r = k_r    # Rotor stiffness
    self.mu = mu      # Friction Coefficient

    self.v_amp = v_amp  # Voltage Amplitude
    self.F_n = F_n      # Preload
    self.T = T          # Load Torque
    self.T_max = self.F_n*self.mu*self.r
    self.phase = 1      # phase
    self.lastSpeed = 0.0
    self.freq_action = 0

    self.pLoss = 0.0
    self.tempMin = tempMin
    self.dt = dt
    self.area = 2*np.pi*((r_b+r_a)*l + r_b**2 - r_a**2)
    self.mass = ru*np.pi*(r_b**2-r_a**2)*l
    self.sigma, self.e, self.s, self.h_c  = sigma, e, s, h_c

    self.freq = freq
    self.temp = temp
    self.targetSpeed = targetSpeed
    self.err = 0
    self.lastErr = 0
    self.speed_noise = 0
    self.action_noise = 0
    self.fail = 0
    
    self.lastEnergy = np.log10(np.abs(-self.targetSpeed)+1)

    freq_range = np.linspace(39,45,100)
    temp_range = np.linspace(20,60,100)
    speed_range = np.linspace(0,300,100)
    torque_range = np.linspace(0,1,100)
    err_range = np.linspace(-300,300,100)
    scaler = np.array([freq_range,temp_range,torque_range, speed_range,speed_range])
    self.mean_scaler = np.mean(scaler,axis=-1)
    self.max_scaler = np.max(scaler,axis=-1)
    self.min_scaler = np.min(scaler,axis=-1)

    self.std_scaler = np.sqrt(np.square(scaler - self.mean_scaler.reshape((-1,1))).sum(axis=-1)/len(freq_range))

  #def scale_obs(self,o):
  #    return (o - self.mean_scaler)/self.std_scaler*2

  def scale_obs(self,o):
      return (o - self.mean_scaler)/(self.max_scaler - self.min_scaler)*2

  def sample_bimodal(self, x_min,x_max):
    std_ = (x_max - x_min)/3
    a = np.random.normal(x_min,std_, 30)
    a = a[a >= x_min] 

    b = np.random.normal(x_max,std_, 30)
    b = b[b <= x_max] 

    c = np.random.choice([a[0],b[0]])
    return np.clip(c,x_min,x_max)

  def update_temp(self,pLoss=None):
    if pLoss == None:
      pLoss = self.pLoss
    powerFlow = pLoss - self.h_c*self.area*(self.temp-self.tempMin) -\
               self.sigma*self.e*self.area*((self.temp+273)**4 - (self.tempMin+273)**4)
    tempRate = powerFlow/self.mass/self.s
    self.temp += self.dt*tempRate
    self.temp = np.clip(self.temp,self.tempMin,60)
    return self.get_state(self.freq)  

  def func_amp(self,w0,*args):
    return_all, = args
    if w0 < -self.wf:
      theta_b = np.pi
      wf = self.wf
    else:
      theta_b = opt.brenth(self.func_thetaB,1e-7,np.pi,args=(w0))
      wf = w0*np.cos(theta_b)
    try:  
      theta_a = opt.brenth(self.func_thetaA,1e-7,np.pi/2,args=(w0,theta_b,wf))
    except:
      theta_a = np.pi/2
    F_N = self.k_r*(w0*(np.sin(2*theta_b)/2 + theta_b) - 2*wf*np.sin(theta_b))
    F_T = 2*self.mu*self.k_r*(self.h/self.r) *\
          (w0*(np.sin(2*theta_a)/2 -np.sin(2*theta_b)/4 + theta_a - theta_b/2) -\
          wf*(2*np.sin(theta_a)-np.sin(theta_b)))
    err= (self.A*self.v_amp)**2 - ((self.c-self.m*self.omega**2)*w0 + F_N)**2 -\
                                  (self.d*self.omega*w0 + F_T)**2
    if return_all:
      return [theta_a, theta_b, wf, F_N, F_T, err]
    else:
      return err 

  def func_thetaA(self,theta_a,*args):
    w0,theta_b,wf = args
    return self.T+self.T_max -\
     4*self.mu*self.k_r*self.r*(w0*np.sin(theta_a)-wf*theta_a)

  def func_thetaB(self,theta_b,*args):
    w0, = args
    return self.F_n -\
     2*self.k_r*w0*(np.sin(theta_b)-theta_b*np.cos(theta_b))

  def get_state(self,freq=None,return_all = False):
    #noi = freq+ self.action_noise*np.random.normal(0,1)
    #print(noi)
    if freq != None:    
        self.freq = freq

    self.omega = 2*np.pi*(self.freq)*1000
    self.c = self.c0*(1-0.0095*np.sqrt(self.temp-self.tempMin))
    self.d = self.d0*(1-0.08*np.sqrt(self.temp-self.tempMin))
    self.m = self.m0
    self.wf = -self.F_n/(2*np.pi*self.k_r)
    omega_n = np.sqrt((self.c + np.pi*self.k_r)/self.m)
    self.w0,r = opt.brenth(self.func_amp,1e-9,1e-5,args=(False),full_output=True)
    self.theta_a, self.theta_b, self.wf, self.F_N, self.F_T, err = self.func_amp(self.w0,True)
    
    self.speed = 60*self.omega*self.h*self.w0/(2*np.pi*self.r**2)*np.cos(self.theta_a)*(self.F_n > 0)* (self.T < self.F_n*self.mu*self.r)*\
            ~((self.omega < (1.03-0.06*self.T/self.T_max)*omega_n) & (self.lastSpeed < 0.1)) * (self.omega > 0.96*omega_n)
    self.speed = round(self.speed,2)
    theta0 = np.arctan2(self.d*self.omega*self.w0 + self.F_T, (self.c-self.m*self.omega**2)*self.w0 + self.F_N)
    if abs(err) > 1:
      print('freq: {}, speed: {}, FN: {}, FT: {}, w0: {}, wf: {},  theta_a: {}, err: {}'.format(freq,self.speed,self.F_N,self.F_T,self.w0,self.wf,self.theta_a,err))
    I = 1j*self.omega*self.w0*np.exp(-1j*theta0)*self.A + (1/self.rd + 1j*self.omega*self.cd)*self.v_amp
    I_amp = np.abs(I)
    I_phase = (np.angle(I,deg=True)  + 2 * 180) % (2 * 180)
    pIn = np.real(self.v_amp*I).clip(0)
    pOut = (self.speed/60*2*np.pi)*self.T

    #FBV = self.w0*self.A/self.cd
    self.err = self.speed - self.targetSpeed

    if ((abs(self.err) - abs(self.lastErr)) > 10):
      self.fail = 1
    else:
      self.fail = 0
        
    self.lastSpeed = self.speed
    self.eff = pOut/pIn*100
    self.pLoss = pIn - pOut
    #a = np.array([1e-2,1e-1,1e0])
    #b =  np.array([1e-2,1e-3,1e-4])            
    energy = 5/300*np.abs(self.err) + 5/np.log10(300)*np.log10(np.abs(self.err)+1) #100*np.abs(self.err)/np.sqrt(self.err**2 + self.targetSpeed **2 +1)
    #eng_dif = 10*1/((err+1)) * derr/du = 10/(err+1)*(err - err(t-1)) ~ 10(1 - err(t-1)/err(t))
    #self.energyDiff = 0.1/((np.abs(self.err)+1))*(np.abs(self.err) - np.abs(self.lastErr))
    self.energyDiff = energy - self.lastEnergy
    #self.energyDiff = self.energyDiff*(0.95+0.05*np.sign(self.err*self.lastErr + 1e-3)) if self.energyDiff < 0 else 1*self.energyDiff
    self.lastEnergy = energy
    self.lastErr = self.err
    if return_all:
      return np.array([self.theta_a, self.speed, self.w0, I_amp, I_phase,pIn, pOut, self.eff])
      #return np.array([self.freq, self.T, self.F_n, self.temp,self.speed,self.targetSpeed, self.eff])
    else:
      return np.array([self.freq, self.temp, self.T, self.speed, self.targetSpeed])

  def get_reward(self,action):
    #diff = self.lastSpeed - self.speed  if self.speed == 0 else 0
    #err = np.abs(self.err)
    #alpha = 25
    #rew = np.sqrt(err) if (err < alpha) else err - alpha + np.sqrt(alpha) 
    L = self.energyDiff + 2*self.lastEnergy
    return - 0.1*np.square(action) - max(L,0)  #-self.fail*10 #+ 0.5*np.sign((action+ 1e-5)*(self.lastErr+1e-5))

  def reset(self,freq=None,temp=None, lastSpeed = 0, T = None, targetSpeed=None, return_all = False):
    self.lastSpeed = 0
    self.freq = self.sample_bimodal(39,45) if freq == None else freq
    self.temp = self.sample_bimodal(20,60) if temp == None else temp
    self.targetSpeed = self.sample_bimodal(0,300) if targetSpeed == None else targetSpeed
    self.lastEnergy = np.abs(-self.targetSpeed)**2
    self.T = self.sample_bimodal(0,1) if T == None else T
    #self.T = 0
    return self.get_state(self.freq) 

  def step_frequency(self,action):          
      #pi_gain = 0.01*action[0]
      #u =  pi_gain*self.err
      self.freq = self.freq + action[0]*2
      self.freq_action = action[0]
      self.freq = np.clip(self.freq,39,45)
      state = self.get_state(self.freq)
      #self.lastSpeed = state[2]
      return state, self.get_reward(action[0]*2), self.fail

  def set_state(self,targetSpeed=None,torque = None):
    if targetSpeed != None:
      self.targetSpeed = targetSpeed
    if torque != None:
      self.T = torque
    return self.get_state(self.freq) 

  def set_temp(self,temp):
    self.temp = temp
  
  def get_temp(self):
      return self.temp
  def get_targetSpeed(self):
      return self.targetSpeed
  def get_speed(self):
      return self.speed
  def get_torque(self):
      return self.T
  def set_torque(self,T):
      self.T = T

  def vary_param(self):
    self.c0 = self.C*self.A**2*(1+0.03*2*(np.random.random()-0.5))
    self.d0 = self.D*self.A**2*(1+0.03*2*(np.random.random()-0.5))
    self.m0 = self.M*self.A**2*(1+0.03*2*(np.random.random()-0.5))
      
  def set_noise(self,speed_noise,action_noise):
    self.speed_noise = speed_noise
    self.action_noise = action_noise 
  
  
    

###################################################################################333
import serial
import struct
import pyvisa

class USM_model_exp:
    def __init__(self):
        self.ser = serial.Serial()
        self.ser.port="COM1"
        self.ser.timeout=0.002
        self.ser.baudrate = 115200
        rm = pyvisa.ResourceManager()
        #print(rm.list_resources())
        self.multimeter = rm.open_resource('GPIB0::2::INSTR')
        self.temp = (self.multimeter.query_ascii_values("MEASure:TEMPerature:TCOuple?")[0])
        self.targetSpeed = 0
        self.speed = 0
        self.fbV = 0
        self.err = 0
        self.lastEnergy = np.log10(np.abs(-self.targetSpeed)+1)
        self.lastErr = -self.targetSpeed
        self.lastSpeed = 0
        self.fail = 0
        self.freq_action = 0

        self.freq = 42
        self.amp = 2.5
        self.T = 0
        self.u_T = 0
        self.T_measured = 0
        self.u3 = int(0)
        self.u4 = int(0)
        self.scope = rm.open_resource('GPIB0::1::INSTR')
        
        freq_range = np.linspace(39,45,100)
        temp_range = np.linspace(20,60,100)
        speed_range = np.linspace(0,300,100)
        torque_range = np.linspace(0,1,100)
        err_range = np.linspace(-300,300,100)
        scaler = np.array([freq_range,temp_range,torque_range, speed_range,speed_range])
        self.mean_scaler = np.mean(scaler,axis=-1)
        self.max_scaler = np.max(scaler,axis=-1)
        self.min_scaler = np.min(scaler,axis=-1)
    
        self.std_scaler = np.sqrt(np.square(scaler - self.mean_scaler.reshape((-1,1))).sum(axis=-1)/len(freq_range))
    
      #def scale_obs(self,o):
      #    return (o - self.mean_scaler)/self.std_scaler*2

    def scale_obs(self,o):
        return (o - self.mean_scaler)/(self.max_scaler - self.min_scaler)*2
    
    def sample_bimodal(self, x_min,x_max):
        std_ = (x_max - x_min)/3
        a = np.random.normal(x_min,std_, 20)
        a = a[a >= x_min] 
    
        b = np.random.normal(x_max,std_, 20)
        b = b[b <= x_max] 
    
        c = np.random.choice([a[0],b[0]])
        return np.clip(c,x_min,x_max)
    
    def to2bytes(self,x):
        bin_x = bin(x)
        #bin_x = bin_x[(bin_x.find('b')+1):]
        n = len(bin_x) - 2
        if n > 8:
            x1 = int(bin_x[-8:],2)
            x2 = int(bin_x[2:-8],2)
        else:

            x1 = int(bin_x[2:],2)
            x2 = 0

        return (x1,x2)
    

    def set_torque(self,T):
        self.T = T
        self.u_T = int(255*(T))
        u_freq = int(65535*(self.freq-39)/(45-39))
        u1,u2 = self.to2bytes(u_freq)
        self.ser.open()
        self.ser.flush()
        self.ser.write(struct.pack('!BBB',u1,u2,self.u_T))
        self.ser.close()
        time.sleep(0.5)
        
    def get_state(self,freq=None,n=16,return_all = False):
        #u = int(255*(freq-39.5)/(45.5-39.5))
        #u = int(255*(freq-40)/(45-40))
        if freq != None:    
            self.freq = freq
        u_freq = int(65535*(self.freq-39)/(45-39))
        u1,u2 = self.to2bytes(u_freq)
        self.ser.open()
        self.ser.flush()
        for i in range(n):
            #self.ser.write(struct.pack('!B',u))
            self.ser.write(struct.pack('!BBB',u1,u2,self.u_T))
            #time.sleep(0.001)
            #x = self.ser.read(2)
            x = self.ser.read(5)
        #x=struct.unpack('!BB',x)
        try:
            x=struct.unpack('!BBBBB',x)
        except:
            self.ser.write(struct.pack('!BBB',u1,u2,self.u_T))
            #time.sleep(0.001)
            #x = self.ser.read(2)
            x = self.ser.read(5)
            x=struct.unpack('!BBBBB',x)
            if x[1] == 255:
                print('Max',x)
        self.ser.close()
        #print(x)
        #self.freq = 40+x[0]/255*(45-40)
        self.speed = (x[0] + x[1]*256)*500/65535
        self.speed = self.speed*(self.speed < 350)
        
        self.speed2 = (x[3] + x[4]*256)*500/65535
        self.speed2 = self.speed2*(self.speed2 < 350)
        
        self.T_measured = x[2]/255*1.2
        self.err = self.speed - self.targetSpeed
        
        if ((abs(self.err) - abs(self.lastErr)) > 10):
            self.fail = 1
        else:
            self.fail = 0
        
        energy =  5/300*np.abs(self.err) + 5/np.log10(300)*np.log10(np.abs(self.err)+1) #np.abs(self.err)**1.5/np.sqrt(self.err**2 + self.targetSpeed **2 +1)
        self.energyDiff = energy - self.lastEnergy
        #self.energyDiff = self.energyDiff*(1.5+0.5*np.sign(self.err*self.lastErr + 1e-3)) if self.energyDiff < 0 else 1.5*self.energyDiff
        self.lastEnergy = energy
        self.lastErr = self.err
        self.lastSpeed = self.speed

        if return_all:
            return np.array([self.freq, self.temp, self.speed, self.fbV, self.T, self.T_measured])
        else:
            return np.array([self.freq, self.temp, self.T, self.speed, self.targetSpeed])
        
    def start(self, amp,freq):
        self.amp = amp
        self.scope.write(":OUTP1:STATe 1")
        self.scope.write(":OUTP1:SYNC:TYPE SFCT")
        self.scope.write(":SOUR1:FREQ " + str(freq*1000))
        self.scope.write(":SOUR1:VOLT:AMPL " + str(amp))
        self.scope.write(":SOUR1:SCH:VOLT:AMPL " + str(amp))
        
    def stop(self):
        self.scope.write(":OUTP:STATe 0")
        #self.scope.write(":OUTP1:SYNC:TYPE OFF")
        self.scope.write(":SOUR1:SCH:VOLT:AMPL 0")
        
    def update_temp(self):
        self.temp = (self.multimeter.query_ascii_values("MEASure:TEMPerature:TCOuple?")[0])
        
    def set_targetSpeed(self,speed):
        self.targetSpeed = speed
        return self.get_state(self.freq) 
    
    def reset(self,freq=None,targetSpeed=None,T = None, temp=None,ep=1):
        self.update_temp()
        self.freq = self.sample_bimodal(39,45) if freq == None else freq
        self.targetSpeed = self.sample_bimodal(0,300) if targetSpeed == None else targetSpeed
        self.lastEnergy = np.abs(-self.targetSpeed)**2
        if ep % 10 == 0:
            self.T = self.sample_bimodal(0,0.8) if T == None else T
            self.set_torque(self.T)
        return self.get_state(self.freq,n=50)
    
    def get_reward(self,action):
        #return -np.sqrt((np.square(self.targetSpeed - self.speed)+1e-5)/(np.sqrt(self.targetSpeed**2 + self.speed**2) + 1e-5))  - 0.1*np.abs(action)
        #return 5*((self.targetSpeed + self.speed)+1e-5)/(np.sqrt(self.targetSpeed**2 + self.speed**2) + 1e-5)/np.sqrt(2)/np.log(np.abs(self.targetSpeed - self.speed) + np.exp(1))
        #return -np.log10(np.power(np.abs(self.targetSpeed - self.speed),3)/(np.sqrt(self.targetSpeed**2 + self.speed**2) + 1e-5)+1e-1) - 0.01*np.abs(action[0]) 
        L = self.energyDiff + 2*self.lastEnergy
        return - 0.1*np.square(action) - max(L,0)

    
    def step_frequency(self,action):          
      #pi_gain = 0.01*action[0]
      #u =  pi_gain*self.err
      self.freq_action = action[0]*2
      self.freq = self.freq + action[0]*2
      self.freq = np.clip(self.freq,39,45)
      state = self.get_state(self.freq)
      #self.lastSpeed = state[2]
      return state, self.get_reward(action[0]*2), self.fail
  
    def set_state(self,targetSpeed=None,torque = None):
        if targetSpeed != None:
            self.targetSpeed = targetSpeed
        if (torque != None) and (torque != self.T):
            self.set_torque(torque)
        return self.get_state(self.freq) 
    
    def get_temp(self):
        return self.temp
    def get_amp(self):
        return self.amp
    def get_targetSpeed(self):
        return self.targetSpeed
    def get_speed(self):
        return self.speed
    def get_torque(self):
      return self.T

    def set_noise(self,speed_noise,action_noise):
        self.speed_noise = speed_noise
        self.action_noise = action_noise 
  
  
def sweep_freq(freqs,return_all = False):
  states = []
  for freq in freqs:
    states.append(USM.get_state(freq,return_all))
  return np.array(states)

def sweep_freq_all(freqs):
  states = []
  for freq in freqs:
    states.append(USM.get_state(freq,return_all=True))
  return np.array(states)

if __name__ == "__main__":
    USM = USM_model_sim()
    
    fig, axs = plt.subplots(4, 2,figsize=(12,16))
    freqs = np.linspace(45,39,100)
    for T in [0,0.1,0.2,0.5,0.7,1]:
      USM.set_state(torque=T)
      print(T)
      states = sweep_freq_all(freqs)
      axs[0,0].plot(freqs,states[:,0]*180/np.pi, label='Torque: {} N.m'.format(T))
      for i in range(1,states.shape[1]):
        axs[i//2,i%2].plot(freqs,states[:,i], label='Torque: {} N.m'.format(T))
        axs[i//2,i%2].legend()
        axs[i//2,i%2].set_xlabel('Driving Frequency [kHz]')
    #axs[0,0].legend()
    axs[0,0].set_ylabel('Theta_a [deg]')
    axs[0,1].set_ylabel('Speed [rpm]')
    axs[1,0].set_ylabel('Vibration Amplitude [μm]')
    
    axs[1,1].set_ylabel('Current Amplitude [A]')
    axs[2,0].set_ylabel('Admittance Phase [°]')
    axs[2,1].set_ylabel('Input Power [W]')
    axs[3,0].set_ylabel('Output Power [W]')
    axs[3,1].set_ylabel('Driving Efficiency [%]')
    
    USM = USM_model_sim()

    plt.figure()
    n = 1000
    freqs_up = np.linspace(39,45,n) 
    freqs_down = np.linspace(45,39,n) 
    
    speeds_up = sweep_freq(freqs_up)[:,3]
    speeds_down = sweep_freq(freqs_down)[:,3]
    plt.figure()
    plt.plot(freqs_up,speeds_up,label='Sweep Up')
    plt.plot(freqs_down,speeds_down,label='Sweep Down')
    plt.xlabel('Frequency [kHz]');
    plt.ylabel('Speed [rpm]');
    plt.title('Speed Hystresis [' + str(n) + ' steps]');
    plt.legend();
    
    freqs = np.linspace(45,39,1000)
    temps = [20,30,40,50]
    plt.figure()
    for temp in temps:
      USM.set_temp(temp)
      speeds = sweep_freq(freqs)[:,3]
      plt.plot(freqs,speeds,label='Temperature = ' + str(temp))
    plt.xlabel('Frequency [kHz]');
    plt.ylabel('Speed [rpm]');
    plt.title('Temperature Drift');
    plt.legend();
    
    dt = 1
    USM.dt = dt
    t = 0
    speeds = []
    times = []
    temps = []
    freq = 41
    USM.reset(temp=20,freq=freq,lastSpeed=1,T=0)
    for i in range(1000):
      state = USM.get_state(freq)
      speed,temp = state[3],state[1]
      temps.append(temp)
      speeds.append(speed)
      times.append(t)
      USM.update_temp()
      t+= dt
    
    fig, ax1 = plt.subplots()
    ax2 = ax1.twinx()
    ax1.plot(times, speeds, 'r-')
    ax2.plot(times, temps, 'b--')
    
    ax1.set_xlabel('Time [s]')
    ax1.set_ylabel('Speed [rpm]', color='r')
    ax2.set_ylabel('Temperature [°C]', color='b')
    ax1.set_title('Temperature Drift')
    plt.show()



    